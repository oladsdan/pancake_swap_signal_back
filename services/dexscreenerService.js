import { request, gql } from 'graphql-request';
import axios from 'axios';
import config from '../config/default.json' assert { type: 'json' };

const DEXSCREENER_API_SEARCH_BASE_URL = config.dexscreenerApiSearchBaseUrl; // Updated base URL
const TARGET_CHAIN_ID = config.targetChainId;
const PREFERRED_QUOTE_TOKEN_SYMBOLS = config.preferredQuoteTokenSymbols.map(s => s.toUpperCase());
const DEXSCREENER_CALL_DELAY_MS = config.dexscreenerCallDelayMs || 0;


const THEGRAPH_API_KEY = process.env.SUBGRAPH_API_KEY;
const PANCAKESWAP_V3_SUBGRAPH_URL = 'https://gateway.thegraph.com/api/subgraphs/id/Hv1GncLY5docZoGtXjo4kwbTvxm3MAhVZqBZE4sUT9eZ';

const SUBGRAPH_HEADERS = {
    'Authorization': `Bearer ${THEGRAPH_API_KEY}`,
};

const QUOTE_TOKEN_ADDRESSES = Object.values(config.quoteTokenMap).map(address => address.toLowerCase());
const HISTORICAL_DATA_DAYS = 60; // For RSI/MACD calculations




const GET_TOKEN_AND_POOL_DATA_V3 = gql`
    query GetTokenAndPoolDataV3($tokenId: String!, $quoteToken0: String!, $quoteToken1: String!) {
        token(id: $tokenId) {
            id
            name
            symbol
            decimals
            derivedUSD # Current price in USD based on its pools
            volumeUSD # Total accumulated volume across all pools for this token
            totalValueLockedUSD # Total accumulated TVL across all pools for this token
            txCount # Total transactions for this token

            tokenDayData(orderBy: date, orderDirection: desc, first: ${HISTORICAL_DATA_DAYS}) {
                date
                priceUSD
                volumeUSD # Daily volume in USD for this token
                totalValueLockedUSD # Daily TVL in USD for this token
            }
        }

        # Query for pools specifically involving our target token and common quote tokens
        # We need to explicitly filter based on token0 or token1 being our target token
        # and the other token being a quote token (WBNB or BUSD).
        pools(
            first: 10, # Fetch a few pools to find the most liquid relevant one
            orderBy: token0__totalValueLockedUSD,
            orderDirection: desc,
            where: {
                or: [
                    {
                        token0_: { id: $tokenId }, # token0 is our target token
                        token1_: { id_in: [$quoteToken0, $quoteToken1] } # token1 is a quote token
                    },
                    {
                        token1_: { id: $tokenId }, # token1 is our target token
                        token0_: { id_in: [$quoteToken0, $quoteToken1] } # token0 is a quote token
                    }
                ]
            }
        ) {
            id # Pool address
            token0 { id symbol decimals }
            token1 { id symbol decimals }
            volumeUSD # Volume in USD for THIS pool
            totalValueLockedUSD # Liquidity in USD for THIS pool
            token0Price # Price of token0 in terms of token1
            token1Price # Price of token1 in terms of token0
            feesUSD # Fees generated by this pool
        }
    }
`;



/**
 * Fetches comprehensive market data for a given target token symbol using Dexscreener's /latest/dex/search endpoint.
 * It queries for the token symbol paired with preferred quote tokens (WBNB/BUSD),
 * filters for PancakeSwap pairs on the target chain, and selects the one with the highest liquidity.
 *
 * @param {object} token - The token object containing symbol and address.
 * @returns {object|null} Structured market data including price, volume, liquidity, and pair metadata.
 */
export async function getMarketData(tokenaddress, tokensymbol) {
    const targetTokenSymbol = tokensymbol;
    const targetTokenAddress = tokenaddress;

    let selectedPair = null;

    // Iterate through preferred quote tokens and try to find a pair
    for (const quoteSymbol of PREFERRED_QUOTE_TOKEN_SYMBOLS) {
        // Construct the query string for the search endpoint
        const queryString = `${targetTokenSymbol}/${quoteSymbol}`;
        const url = `${DEXSCREENER_API_SEARCH_BASE_URL}?q=${queryString}`;
        console.log(`Fetching Dexscreener data for ${queryString} from: ${url}`);

        try {
            const response = await axios.get(url);

            if (!response.data || !response.data.pairs || response.data.pairs.length === 0) {
                console.log(`Dexscreener: No pairs found for query  "${queryString}". Trying next quote token...`);



                continue; // Try the next preferred quote token
            }

           
            const allPairsForQuery = response.data.pairs;

            // Filter for PancakeSwap and the exact chain ID
            const relevantPairs = allPairsForQuery.filter(pair => {
                const isPancakeSwap = pair.dexId.toLowerCase() === 'pancakeswap';
                const isOnTargetChain = pair.chainId.toLowerCase() === TARGET_CHAIN_ID.toLowerCase();

                // Ensure that our target token address is part of this pair
                const isTargetTokenInPair =
                    pair.baseToken.address.toLowerCase() === targetTokenAddress.toLowerCase() ||
                    pair.quoteToken.address.toLowerCase() === targetTokenAddress.toLowerCase();

                // Ensure the quote token is the one we are currently trying to match (WBNB or BUSD)
                const isQuoteTokenMatched = pair.quoteToken.symbol.toUpperCase() === quoteSymbol.toUpperCase();

                // Also ensure it has some liquidity (important to filter out defunct pairs)
                const hasLiquidity = pair.liquidity && pair.liquidity.usd > 0;

                return isPancakeSwap && isOnTargetChain && isTargetTokenInPair && isQuoteTokenMatched && hasLiquidity;
            });

            if (relevantPairs.length > 0) {
                // Sort by liquidity (USD) in descending order to pick the most liquid pair
                relevantPairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0));
                selectedPair = relevantPairs[0];
                break; // Found a suitable pair, stop searching
            }

        } catch (error) {
            if (error.response && error.response.status === 429) {
                console.error("Dexscreener rate limit hit:", error.message);
                throw { isRateLimit: true, message: "Dexscreener rate limit hit" };
            }
            if (axios.isAxiosError(error) && error.response) {
                console.error(`Dexscreener API error for ${queryString} (HTTP ${error.response.status}):`, error.response.data);
            } else {
                console.error(`Failed to get market data for ${queryString} from Dexscreener:`, error.message);
            }
            // Continue to next quote symbol if there's an error for the current one
            throw error; // Re-throw other errors
            // continue;
        } finally {
            // Implement the delay AFTER each API call, whether it succeeded or failed
            if (DEXSCREENER_CALL_DELAY_MS > 0) {
                await new Promise(resolve => setTimeout(resolve, DEXSCREENER_CALL_DELAY_MS));
            
            }
        }

         //fallback to sugraph


    }

    if (!selectedPair) {
        console.warn(`Dexscreener: No suitable PancakeSwap pair with WBNB/BUSD found for ${targetTokenSymbol} (${targetTokenAddress}) on chain ${TARGET_CHAIN_ID}. falling back to subgraph`); 

        try {

                // const { address: targetTokenAddress, symbol: targetTokenSymbol, name: targetTokenName } = tokenConfig;
                const lowerCaseTokenAddress = targetTokenAddress.toLowerCase();
                let marketData = null;
                let historicalPrices = [];

            // --- 1. Try to fetch from PancakeSwap V3 Subgraph ---
                console.log(`Attempting to fetch market data for ${targetTokenSymbol} from PancakeSwap V3 Subgraph...`);
                
                if(!THEGRAPH_API_KEY) {
                        console.warn("THEGRAPH_API_KEY is not set. Skipping Subgraph query.");
                        throw new Error("THEGRAPH_API_KEY not configured.");
                }

                const variables = {
                tokenId: lowerCaseTokenAddress,
                quoteToken0: config.quoteTokenMap.WBNB.toLowerCase(), // Pass quote token addresses as variables
                quoteToken1: config.quoteTokenMap.BUSD.toLowerCase()
                };

                 console.log("this is variables", variables);

                const subgraphResponse = await request(
                        PANCAKESWAP_V3_SUBGRAPH_URL,
                        GET_TOKEN_AND_POOL_DATA_V3, // Use the new combined query
                        variables,
                        SUBGRAPH_HEADERS
                );
                console.log(`Subgraph response for ${targetTokenSymbol}:`, subgraphResponse);

                const token = subgraphResponse.token;
                const pools = subgraphResponse.pools; // Get the pools data

                 let tokenPriceUsd;

                 for (let i = 0; i < pools.length; i++) {
                // console.log(Number(pools[i].token1Price.length)).toFixed(2)
                const formattedPrice = Number(pools[i].token1Price).toFixed(2);
        
                if (pools[i].token1.symbol === 'BUSD' && formattedPrice < 10000 ) {
                tokenPriceUsd = Number(pools[i].token1Price).toFixed(2);
                // console.log(tokenPriceUsd)
                break;
        } 
    }

    if (token) {
            console.log(`Token data found for ${targetTokenSymbol} on V3 Subgraph.`);

            let currentPrice = tokenPriceUsd;
            let currentVolume = Number(parseFloat(token.volumeUSD)).toFixed(2);
            let currentLiquidity = Number(parseFloat(token.totalValueLockedUSD)).toFixed(2);
            let pairAddressUsed = lowerCaseTokenAddress; // Default to token address if no specific pool found

            // Find the most liquid relevant pool to get precise current data
            let mainPool = null;
            if (pools && pools.length > 0) {
                // Filter pools to only those involving our target token and a preferred quote token (WBNB/BUSD)
                const relevantPools = pools.filter(p =>
                    (p.token0.id === lowerCaseTokenAddress && QUOTE_TOKEN_ADDRESSES.includes(p.token1.id)) ||
                    (p.token1.id === lowerCaseTokenAddress && QUOTE_TOKEN_ADDRESSES.includes(p.token0.id))
                );

                if (relevantPools.length > 0) {
                    mainPool = relevantPools.sort((a, b) => parseFloat(b.totalValueLockedUSD) - parseFloat(a.totalValueLockedUSD))[0];
                } else {
                    // If no preferred quote token pool, just take the most liquid one from the fetched set
                    mainPool = pools.sort((a, b) => parseFloat(b.totalValueLockedUSD) - parseFloat(a.totalValueLockedUSD))[0];
                }

                if (mainPool) {
                    console.log(`Using data from most liquid pool for ${targetTokenSymbol}: ${mainPool.id}`);
                    currentLiquidity = parseFloat(mainPool.totalValueLockedUSD).toFixed(2);
                    currentVolume = parseFloat(mainPool.volumeUSD).toFixed(2);
                    pairAddressUsed = mainPool.id; // Use the pool ID as the primary pair address

                    if (mainPool.token0.id === lowerCaseTokenAddress) {
                        currentPrice = parseFloat(mainPool.token0Price).toFixed(config.priceDecimals);
                    } else if (mainPool.token1.id === lowerCaseTokenAddress) {
                        currentPrice = parseFloat(mainPool.token1Price).toFixed(config.priceDecimals);
                    }
                }
            }


            // Collect historical daily prices from tokenDayData
            if (token.tokenDayData && token.tokenDayData.length > 0) {
                historicalPrices = token.tokenDayData
                    .map(d => ({ date: d.date, price: parseFloat(d.priceUSD) }))
                    .sort((a, b) => a.date - b.date); // Sort by date ascending for indicator calculations
            }

            // Check if we have enough historical data for indicators
            if (historicalPrices.length < config.minHistoricalDataPoints) {
                console.warn(`Insufficient historical data from Subgraph for ${targetTokenSymbol} (${historicalPrices.length} days, needed ${config.minHistoricalDataPoints}). Falling back to Dexscreener for everything.`);
                throw new Error("Insufficient historical data from Subgraph."); // Force fallback
            }

            marketData = {
                pairAddress: pairAddressUsed,
                chainId: config.targetChainId,
                pairName: `${targetTokenSymbol}/${config.baseCurrencySymbol}`,
                baseToken: { address: targetTokenAddress, symbol: targetTokenSymbol },
                quoteToken: { address: config.quoteTokenMap.WBNB, symbol: WBNB }, // Default to WBNB for consistency
                currentPrice: tokenPriceUsd,
                currentVolume: currentVolume,
                currentLiquidity: currentLiquidity,
                historicalPrices: historicalPrices,
            };

            console.log("the marketData", marketData)

            return marketData; // Return if subgraph data is sufficient
        } else {
              console.warn(`No token data found for ${targetTokenSymbol} on V3 Subgraph. skipping.`)



        }


            
        } catch (error) {
            
        }
        
    }

    // Extract relevant data from the selected pair
    const currentPrice = parseFloat(selectedPair.priceUsd) || 0;
    const currentVolume = parseFloat(selectedPair.volume?.h24) || 0; // Using h24 volume as requested
    const currentLiquidity = parseFloat(selectedPair.liquidity?.usd) || 0;

    // Map baseToken and quoteToken correctly for our internal schema
    // The target token might be base or quote in Dexscreener's response
    let baseTokenData, quoteTokenData;
    if (selectedPair.baseToken.address.toLowerCase() === targetTokenAddress.toLowerCase()) {
        baseTokenData = selectedPair.baseToken;
        quoteTokenData = selectedPair.quoteToken;
    } else if (selectedPair.quoteToken.address.toLowerCase() === targetTokenAddress.toLowerCase()) {
        baseTokenData = selectedPair.baseToken;
        quoteTokenData = selectedPair.quoteToken;
    } else {
        // Fallback or error: this should ideally not happen if filtering is correct
        console.error(`Logic error: Target token ${targetTokenAddress} not found as base or quote in selected pair ${selectedPair.pairAddress}`);
        return null;
    }

    // Return a structured object matching what index.js and dataService expect

    console.log({
        pairAddress: selectedPair.pairAddress,
        chainId: selectedPair.chainId,
        pairName: `${baseTokenData.symbol}/${quoteTokenData.symbol}`, // Ensure correct naming, e.g., TUT/WBNB
        baseToken: baseTokenData,
        quoteToken: quoteTokenData,
        currentPrice,
        currentVolume,
        currentLiquidity
    })

    return {
        pairAddress: selectedPair.pairAddress,
        chainId: selectedPair.chainId,
        pairName: `${baseTokenData.symbol}/${quoteTokenData.symbol}`, // Ensure correct naming, e.g., TUT/WBNB
        baseToken: baseTokenData,
        quoteToken: quoteTokenData,
        currentPrice,
        currentVolume,
        currentLiquidity
    };

    //fallbackt to subgraph


}
